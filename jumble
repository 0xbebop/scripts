#!/usr/bin/env python3
import click, codecs, hashlib
from Crypto.Cipher import AES
from Crypto import Random

#base64 encoding
def b64(msg):
	msg = bytes(msg, 'ascii')
	msg = codecs.encode(msg, encoding='base64',errors='strict')
	msg = msg.decode('ascii')
	return msg

#base64 decoding
def b64d(msg):
	msg = codecs.decode(msg, encoding='base64',errors='strict')
	msg = msg.decode('ascii')
	return msg

#hex encoding
def j_hex(msg):
	msg = msg.encode('ascii')
	msg = msg.hex()
	return msg

#hex decoding
def j_hexd(msg):
	msg = bytes.fromhex(msg).decode('ascii')
	return msg

#utf-8 encoding
def utf8(msg):
	msg = bytes(msg, 'ascii')
	msg = codecs.encode(msg, encoding='utf-8', errors='strict')
	msg = msg.decode('ascii')
	return msg

#utf-8 decoding
def utf8d(msg):
	msg = codecs.decode(msg, encoding='utf-8', errors='strict')
	msg = msg.decode('ascii')
	return msg

#AES block defining
BLOCK_SIZE = 16
pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)
unpad = lambda s: s[:-ord(s[len(s) - 1:])]

#AES encrypting
def aes(msg, key):
	p_key = hashlib.sha256(key.encode("utf-8")).digest()
	msg = pad(msg)
	print("After padding:",msg)
	iv = Random.new().read(AES.block_size)
	cipher = AES.new(p_key, AES.MODE_CBC, iv)
	return base64.b64encode(iv + cipher.encrypt(msg))

#AES decrypting
def aesd(msg, key):
	p_key = hashlib.sha256(key.encode("utf-8")).digest()
	msg = base64.b64decode(msg)
	iv = msg[:16]
	cipher = AES.new(p_key, AES.MODE_CBC, iv)
	return unpad

text = "text"

#Running the linux commands
@click.command()
@click.option('--encode', '-e', help='Scramble that information.')
def main(encode):

	'''
	Jumble solves all your problems.  Got a blob of shit that don't make sense? Jumble that b.  Got a blob of shit that makes sense?  JUMBLE THAT B.
	'''

	func_list = [b64, b64d, j_hex, j_hexd, aes, aesd]

if __name__ == '__main__':
	main()
